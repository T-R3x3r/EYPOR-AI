{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/Bebob/Dropbox/University/MA425 Project in Operations Research/EYProjectGit/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { BehaviorSubject } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./api.service\";\nexport class DatabaseTrackingService {\n  constructor(apiService) {\n    this.apiService = apiService;\n    this.changes = [];\n    this.highlightedCells = new Map();\n    this.changesSubject = new BehaviorSubject([]);\n    this.highlightedCellsSubject = new BehaviorSubject(new Map());\n    // Human-in-the-loop for model rerun\n    this.pendingRerunRequest = null;\n    this.rerunRequestSubject = new BehaviorSubject(null);\n    this.availableModels = [];\n    this.availableModelsSubject = new BehaviorSubject([]);\n  }\n  // Observable for components to subscribe to changes\n  getChanges() {\n    return this.changesSubject.asObservable();\n  }\n  // Observable for highlighted cells\n  getHighlightedCells() {\n    return this.highlightedCellsSubject.asObservable();\n  }\n  // Observable for model rerun requests\n  getRerunRequest() {\n    return this.rerunRequestSubject.asObservable();\n  }\n  // Observable for available models\n  getAvailableModels() {\n    return this.availableModelsSubject.asObservable();\n  }\n  // Record a database change\n  recordChange(table, column, row_id, old_value, new_value) {\n    const change = {\n      table,\n      column,\n      row_id,\n      old_value,\n      new_value,\n      timestamp: new Date()\n    };\n    this.changes.push(change);\n    this.changesSubject.next([...this.changes]);\n    // Add to highlighted cells\n    const cellKey = `${table}_${column}_${row_id}`;\n    const cellChange = {\n      table,\n      column,\n      row_id,\n      highlighted: true,\n      timestamp: new Date()\n    };\n    this.highlightedCells.set(cellKey, cellChange);\n    this.highlightedCellsSubject.next(new Map(this.highlightedCells));\n    // Auto-remove highlight after 10 seconds\n    setTimeout(() => {\n      this.removeHighlight(cellKey);\n    }, 10000);\n    // Trigger human-in-the-loop for model rerun decision\n    this.requestModelRerun(`${table}.${column}`, old_value, new_value);\n  }\n  // Check if a cell should be highlighted\n  isCellHighlighted(table, column, row_id) {\n    const cellKey = `${table}_${column}_${row_id}`;\n    return this.highlightedCells.has(cellKey);\n  }\n  // Get cell change info\n  getCellChange(table, column, row_id) {\n    const cellKey = `${table}_${column}_${row_id}`;\n    return this.highlightedCells.get(cellKey) || null;\n  }\n  // Remove highlight for a specific cell\n  removeHighlight(cellKey) {\n    if (this.highlightedCells.has(cellKey)) {\n      this.highlightedCells.delete(cellKey);\n      this.highlightedCellsSubject.next(new Map(this.highlightedCells));\n    }\n  }\n  // Clear all highlights\n  clearAllHighlights() {\n    this.highlightedCells.clear();\n    this.highlightedCellsSubject.next(new Map());\n  }\n  // Get all changes for a specific table\n  getTableChanges(table) {\n    return this.changes.filter(change => change.table === table);\n  }\n  // Clear all changes\n  clearChanges() {\n    this.changes = [];\n    this.changesSubject.next([]);\n    this.clearAllHighlights();\n  }\n  // Parse database modification response to extract changes\n  parseModificationResponse(response) {\n    try {\n      // Look for patterns like \"Updated table X, column Y from A to B\"\n      const updatePattern = /Updated table (\\w+), column (\\w+) from (.+) to (.+)/g;\n      const paramPattern = /Parameter (\\w+) updated from (.+) to (.+)/g;\n      let match;\n      // Handle table updates\n      while ((match = updatePattern.exec(response)) !== null) {\n        const [, table, column, oldValue, newValue] = match;\n        // For parameter updates, we don't have specific row IDs, so use 'param'\n        this.recordChange(table, column, 'param', oldValue.trim(), newValue.trim());\n      }\n      // Handle parameter updates\n      while ((match = paramPattern.exec(response)) !== null) {\n        const [, paramName, oldValue, newValue] = match;\n        // Try to map parameter names to table/column combinations\n        this.recordChange('parameters', paramName, 'param', oldValue.trim(), newValue.trim());\n      }\n    } catch (error) {\n      console.error('Error parsing modification response:', error);\n    }\n  }\n  // Human-in-the-loop: Request model rerun decision\n  requestModelRerun(changeLocation, oldValue, newValue) {\n    // Don't create duplicate requests\n    if (this.pendingRerunRequest && this.pendingRerunRequest.status === 'pending') {\n      return;\n    }\n    const changeDescription = `Modified ${changeLocation}: ${oldValue} → ${newValue}`;\n    // Discover available models\n    this.discoverAvailableModels().then(models => {\n      const request = {\n        id: Date.now().toString(),\n        change_description: changeDescription,\n        available_models: models.map(m => m.filename),\n        recommended_model: models.find(m => m.type === 'runall')?.filename,\n        timestamp: new Date(),\n        status: 'pending'\n      };\n      this.pendingRerunRequest = request;\n      this.rerunRequestSubject.next(request);\n      this.availableModelsSubject.next(models);\n    });\n  }\n  // Discover available models in the project\n  discoverAvailableModels() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      try {\n        const response = yield _this.apiService.discoverModels().toPromise();\n        const models = [];\n        // Common model file patterns\n        const modelPatterns = [{\n          pattern: /runall/i,\n          type: 'runall',\n          description: 'Run all models'\n        }, {\n          pattern: /main\\.py$/i,\n          type: 'main',\n          description: 'Main execution script'\n        }, {\n          pattern: /model.*\\.py$/i,\n          type: 'model',\n          description: 'Model script'\n        }, {\n          pattern: /run.*\\.py$/i,\n          type: 'model',\n          description: 'Run script'\n        }, {\n          pattern: /execute.*\\.py$/i,\n          type: 'model',\n          description: 'Execute script'\n        }];\n        // Process discovered files from backend\n        const discoveredFiles = response.files || [];\n        discoveredFiles.forEach(filename => {\n          for (const pattern of modelPatterns) {\n            if (pattern.pattern.test(filename)) {\n              models.push({\n                filename,\n                type: pattern.type,\n                description: pattern.description,\n                highlighted: pattern.type === 'runall' // Highlight runall files\n              });\n\n              break;\n            }\n          }\n        });\n        // If no files discovered from backend, use fallback\n        if (models.length === 0) {\n          const fallbackFiles = ['runall.py', 'runall.bat', 'run_all_models.py', 'main.py', 'model_runner.py', 'execute_model.py', 'run_analysis.py'];\n          fallbackFiles.forEach(filename => {\n            for (const pattern of modelPatterns) {\n              if (pattern.pattern.test(filename)) {\n                models.push({\n                  filename,\n                  type: pattern.type,\n                  description: pattern.description,\n                  highlighted: pattern.type === 'runall'\n                });\n                break;\n              }\n            }\n          });\n        }\n        return models;\n      } catch (error) {\n        console.error('Error discovering models:', error);\n        return [];\n      }\n    })();\n  }\n  // User approves model rerun\n  approveModelRerun(selectedModel) {\n    if (this.pendingRerunRequest) {\n      this.pendingRerunRequest.status = 'approved';\n      this.pendingRerunRequest.selected_model = selectedModel;\n      this.rerunRequestSubject.next(this.pendingRerunRequest);\n      console.log(`User approved rerunning model: ${selectedModel}`);\n      // Here you would typically call the backend to execute the selected model\n      this.executeModel(selectedModel);\n    }\n  }\n  // User rejects model rerun\n  rejectModelRerun() {\n    if (this.pendingRerunRequest) {\n      this.pendingRerunRequest.status = 'rejected';\n      this.rerunRequestSubject.next(this.pendingRerunRequest);\n      console.log('User rejected model rerun');\n      // Clear the request after a delay\n      setTimeout(() => {\n        this.clearRerunRequest();\n      }, 2000);\n    }\n  }\n  // Clear the current rerun request\n  clearRerunRequest() {\n    this.pendingRerunRequest = null;\n    this.rerunRequestSubject.next(null);\n    this.availableModelsSubject.next([]);\n  }\n  // Execute the selected model\n  executeModel(modelFilename) {\n    console.log(`Executing model: ${modelFilename}`);\n    this.apiService.executeModel(modelFilename).subscribe({\n      next: response => {\n        console.log('Model execution response:', response);\n        // Handle successful execution\n        setTimeout(() => {\n          this.clearRerunRequest();\n        }, 1000);\n      },\n      error: error => {\n        console.error('Model execution error:', error);\n        // Handle execution error\n        setTimeout(() => {\n          this.clearRerunRequest();\n        }, 1000);\n      }\n    });\n  }\n  static {\n    this.ɵfac = function DatabaseTrackingService_Factory(t) {\n      return new (t || DatabaseTrackingService)(i0.ɵɵinject(i1.ApiService));\n    };\n  }\n  static {\n    this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: DatabaseTrackingService,\n      factory: DatabaseTrackingService.ɵfac,\n      providedIn: 'root'\n    });\n  }\n}","map":{"version":3,"names":["BehaviorSubject","DatabaseTrackingService","constructor","apiService","changes","highlightedCells","Map","changesSubject","highlightedCellsSubject","pendingRerunRequest","rerunRequestSubject","availableModels","availableModelsSubject","getChanges","asObservable","getHighlightedCells","getRerunRequest","getAvailableModels","recordChange","table","column","row_id","old_value","new_value","change","timestamp","Date","push","next","cellKey","cellChange","highlighted","set","setTimeout","removeHighlight","requestModelRerun","isCellHighlighted","has","getCellChange","get","delete","clearAllHighlights","clear","getTableChanges","filter","clearChanges","parseModificationResponse","response","updatePattern","paramPattern","match","exec","oldValue","newValue","trim","paramName","error","console","changeLocation","status","changeDescription","discoverAvailableModels","then","models","request","id","now","toString","change_description","available_models","map","m","filename","recommended_model","find","type","_this","_asyncToGenerator","discoverModels","toPromise","modelPatterns","pattern","description","discoveredFiles","files","forEach","test","length","fallbackFiles","approveModelRerun","selectedModel","selected_model","log","executeModel","rejectModelRerun","clearRerunRequest","modelFilename","subscribe","i0","ɵɵinject","i1","ApiService","factory","ɵfac","providedIn"],"sources":["C:\\Users\\Bebob\\Dropbox\\University\\MA425 Project in Operations Research\\EYProjectGit\\frontend\\src\\app\\services\\database-tracking.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\r\nimport { BehaviorSubject, Observable } from 'rxjs';\r\nimport { ApiService } from './api.service';\r\n\r\ninterface DatabaseChange {\r\n  table: string;\r\n  column: string;\r\n  row_id: string | number;\r\n  old_value: any;\r\n  new_value: any;\r\n  timestamp: Date;\r\n}\r\n\r\ninterface CellChange {\r\n  table: string;\r\n  column: string;\r\n  row_id: string | number;\r\n  highlighted: boolean;\r\n  timestamp: Date;\r\n}\r\n\r\ninterface ModelRerunRequest {\r\n  id: string;\r\n  change_description: string;\r\n  available_models: string[];\r\n  recommended_model?: string;\r\n  timestamp: Date;\r\n  status: 'pending' | 'approved' | 'rejected';\r\n  selected_model?: string;\r\n}\r\n\r\ninterface AvailableModel {\r\n  filename: string;\r\n  type: 'runall' | 'main' | 'model' | 'other';\r\n  description: string;\r\n  highlighted: boolean;\r\n}\r\n\r\n@Injectable({\r\n  providedIn: 'root'\r\n})\r\nexport class DatabaseTrackingService {\r\n  private changes: DatabaseChange[] = [];\r\n  private highlightedCells: Map<string, CellChange> = new Map();\r\n  private changesSubject = new BehaviorSubject<DatabaseChange[]>([]);\r\n  private highlightedCellsSubject = new BehaviorSubject<Map<string, CellChange>>(new Map());\r\n  \r\n  // Human-in-the-loop for model rerun\r\n  private pendingRerunRequest: ModelRerunRequest | null = null;\r\n  private rerunRequestSubject = new BehaviorSubject<ModelRerunRequest | null>(null);\r\n  private availableModels: AvailableModel[] = [];\r\n  private availableModelsSubject = new BehaviorSubject<AvailableModel[]>([]);\r\n\r\n  constructor(private apiService: ApiService) {}\r\n\r\n  // Observable for components to subscribe to changes\r\n  getChanges(): Observable<DatabaseChange[]> {\r\n    return this.changesSubject.asObservable();\r\n  }\r\n\r\n  // Observable for highlighted cells\r\n  getHighlightedCells(): Observable<Map<string, CellChange>> {\r\n    return this.highlightedCellsSubject.asObservable();\r\n  }\r\n\r\n  // Observable for model rerun requests\r\n  getRerunRequest(): Observable<ModelRerunRequest | null> {\r\n    return this.rerunRequestSubject.asObservable();\r\n  }\r\n\r\n  // Observable for available models\r\n  getAvailableModels(): Observable<AvailableModel[]> {\r\n    return this.availableModelsSubject.asObservable();\r\n  }\r\n\r\n  // Record a database change\r\n  recordChange(table: string, column: string, row_id: string | number, old_value: any, new_value: any): void {\r\n    const change: DatabaseChange = {\r\n      table,\r\n      column,\r\n      row_id,\r\n      old_value,\r\n      new_value,\r\n      timestamp: new Date()\r\n    };\r\n\r\n    this.changes.push(change);\r\n    this.changesSubject.next([...this.changes]);\r\n\r\n    // Add to highlighted cells\r\n    const cellKey = `${table}_${column}_${row_id}`;\r\n    const cellChange: CellChange = {\r\n      table,\r\n      column,\r\n      row_id,\r\n      highlighted: true,\r\n      timestamp: new Date()\r\n    };\r\n\r\n    this.highlightedCells.set(cellKey, cellChange);\r\n    this.highlightedCellsSubject.next(new Map(this.highlightedCells));\r\n\r\n    // Auto-remove highlight after 10 seconds\r\n    setTimeout(() => {\r\n      this.removeHighlight(cellKey);\r\n    }, 10000);\r\n\r\n    // Trigger human-in-the-loop for model rerun decision\r\n    this.requestModelRerun(`${table}.${column}`, old_value, new_value);\r\n  }\r\n\r\n  // Check if a cell should be highlighted\r\n  isCellHighlighted(table: string, column: string, row_id: string | number): boolean {\r\n    const cellKey = `${table}_${column}_${row_id}`;\r\n    return this.highlightedCells.has(cellKey);\r\n  }\r\n\r\n  // Get cell change info\r\n  getCellChange(table: string, column: string, row_id: string | number): CellChange | null {\r\n    const cellKey = `${table}_${column}_${row_id}`;\r\n    return this.highlightedCells.get(cellKey) || null;\r\n  }\r\n\r\n  // Remove highlight for a specific cell\r\n  removeHighlight(cellKey: string): void {\r\n    if (this.highlightedCells.has(cellKey)) {\r\n      this.highlightedCells.delete(cellKey);\r\n      this.highlightedCellsSubject.next(new Map(this.highlightedCells));\r\n    }\r\n  }\r\n\r\n  // Clear all highlights\r\n  clearAllHighlights(): void {\r\n    this.highlightedCells.clear();\r\n    this.highlightedCellsSubject.next(new Map());\r\n  }\r\n\r\n  // Get all changes for a specific table\r\n  getTableChanges(table: string): DatabaseChange[] {\r\n    return this.changes.filter(change => change.table === table);\r\n  }\r\n\r\n  // Clear all changes\r\n  clearChanges(): void {\r\n    this.changes = [];\r\n    this.changesSubject.next([]);\r\n    this.clearAllHighlights();\r\n  }\r\n\r\n  // Parse database modification response to extract changes\r\n  parseModificationResponse(response: string): void {\r\n    try {\r\n      // Look for patterns like \"Updated table X, column Y from A to B\"\r\n      const updatePattern = /Updated table (\\w+), column (\\w+) from (.+) to (.+)/g;\r\n      const paramPattern = /Parameter (\\w+) updated from (.+) to (.+)/g;\r\n      \r\n      let match;\r\n      \r\n      // Handle table updates\r\n      while ((match = updatePattern.exec(response)) !== null) {\r\n        const [, table, column, oldValue, newValue] = match;\r\n        // For parameter updates, we don't have specific row IDs, so use 'param'\r\n        this.recordChange(table, column, 'param', oldValue.trim(), newValue.trim());\r\n      }\r\n      \r\n      // Handle parameter updates\r\n      while ((match = paramPattern.exec(response)) !== null) {\r\n        const [, paramName, oldValue, newValue] = match;\r\n        // Try to map parameter names to table/column combinations\r\n        this.recordChange('parameters', paramName, 'param', oldValue.trim(), newValue.trim());\r\n      }\r\n    } catch (error) {\r\n      console.error('Error parsing modification response:', error);\r\n    }\r\n  }\r\n\r\n  // Human-in-the-loop: Request model rerun decision\r\n  private requestModelRerun(changeLocation: string, oldValue: any, newValue: any): void {\r\n    // Don't create duplicate requests\r\n    if (this.pendingRerunRequest && this.pendingRerunRequest.status === 'pending') {\r\n      return;\r\n    }\r\n\r\n    const changeDescription = `Modified ${changeLocation}: ${oldValue} → ${newValue}`;\r\n    \r\n    // Discover available models\r\n    this.discoverAvailableModels().then(models => {\r\n      const request: ModelRerunRequest = {\r\n        id: Date.now().toString(),\r\n        change_description: changeDescription,\r\n        available_models: models.map(m => m.filename),\r\n        recommended_model: models.find(m => m.type === 'runall')?.filename,\r\n        timestamp: new Date(),\r\n        status: 'pending'\r\n      };\r\n\r\n      this.pendingRerunRequest = request;\r\n      this.rerunRequestSubject.next(request);\r\n      this.availableModelsSubject.next(models);\r\n    });\r\n  }\r\n\r\n  // Discover available models in the project\r\n  private async discoverAvailableModels(): Promise<AvailableModel[]> {\r\n    try {\r\n      const response = await this.apiService.discoverModels().toPromise();\r\n      const models: AvailableModel[] = [];\r\n      \r\n      // Common model file patterns\r\n      const modelPatterns = [\r\n        { pattern: /runall/i, type: 'runall' as const, description: 'Run all models' },\r\n        { pattern: /main\\.py$/i, type: 'main' as const, description: 'Main execution script' },\r\n        { pattern: /model.*\\.py$/i, type: 'model' as const, description: 'Model script' },\r\n        { pattern: /run.*\\.py$/i, type: 'model' as const, description: 'Run script' },\r\n        { pattern: /execute.*\\.py$/i, type: 'model' as const, description: 'Execute script' }\r\n      ];\r\n\r\n      // Process discovered files from backend\r\n      const discoveredFiles = response.files || [];\r\n      \r\n      discoveredFiles.forEach((filename: string) => {\r\n        for (const pattern of modelPatterns) {\r\n          if (pattern.pattern.test(filename)) {\r\n            models.push({\r\n              filename,\r\n              type: pattern.type,\r\n              description: pattern.description,\r\n              highlighted: pattern.type === 'runall' // Highlight runall files\r\n            });\r\n            break;\r\n          }\r\n        }\r\n      });\r\n\r\n      // If no files discovered from backend, use fallback\r\n      if (models.length === 0) {\r\n        const fallbackFiles = [\r\n          'runall.py',\r\n          'runall.bat', \r\n          'run_all_models.py',\r\n          'main.py',\r\n          'model_runner.py',\r\n          'execute_model.py',\r\n          'run_analysis.py'\r\n        ];\r\n\r\n        fallbackFiles.forEach(filename => {\r\n          for (const pattern of modelPatterns) {\r\n            if (pattern.pattern.test(filename)) {\r\n              models.push({\r\n                filename,\r\n                type: pattern.type,\r\n                description: pattern.description,\r\n                highlighted: pattern.type === 'runall'\r\n              });\r\n              break;\r\n            }\r\n          }\r\n        });\r\n      }\r\n\r\n      return models;\r\n    } catch (error) {\r\n      console.error('Error discovering models:', error);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  // User approves model rerun\r\n  approveModelRerun(selectedModel: string): void {\r\n    if (this.pendingRerunRequest) {\r\n      this.pendingRerunRequest.status = 'approved';\r\n      this.pendingRerunRequest.selected_model = selectedModel;\r\n      this.rerunRequestSubject.next(this.pendingRerunRequest);\r\n      \r\n      console.log(`User approved rerunning model: ${selectedModel}`);\r\n      // Here you would typically call the backend to execute the selected model\r\n      this.executeModel(selectedModel);\r\n    }\r\n  }\r\n\r\n  // User rejects model rerun\r\n  rejectModelRerun(): void {\r\n    if (this.pendingRerunRequest) {\r\n      this.pendingRerunRequest.status = 'rejected';\r\n      this.rerunRequestSubject.next(this.pendingRerunRequest);\r\n      \r\n      console.log('User rejected model rerun');\r\n      // Clear the request after a delay\r\n      setTimeout(() => {\r\n        this.clearRerunRequest();\r\n      }, 2000);\r\n    }\r\n  }\r\n\r\n  // Clear the current rerun request\r\n  clearRerunRequest(): void {\r\n    this.pendingRerunRequest = null;\r\n    this.rerunRequestSubject.next(null);\r\n    this.availableModelsSubject.next([]);\r\n  }\r\n\r\n  // Execute the selected model\r\n  private executeModel(modelFilename: string): void {\r\n    console.log(`Executing model: ${modelFilename}`);\r\n    \r\n    this.apiService.executeModel(modelFilename).subscribe({\r\n      next: (response) => {\r\n        console.log('Model execution response:', response);\r\n        // Handle successful execution\r\n        setTimeout(() => {\r\n          this.clearRerunRequest();\r\n        }, 1000);\r\n      },\r\n      error: (error) => {\r\n        console.error('Model execution error:', error);\r\n        // Handle execution error\r\n        setTimeout(() => {\r\n          this.clearRerunRequest();\r\n        }, 1000);\r\n      }\r\n    });\r\n  }\r\n} "],"mappings":";AACA,SAASA,eAAe,QAAoB,MAAM;;;AAwClD,OAAM,MAAOC,uBAAuB;EAYlCC,YAAoBC,UAAsB;IAAtB,KAAAA,UAAU,GAAVA,UAAU;IAXtB,KAAAC,OAAO,GAAqB,EAAE;IAC9B,KAAAC,gBAAgB,GAA4B,IAAIC,GAAG,EAAE;IACrD,KAAAC,cAAc,GAAG,IAAIP,eAAe,CAAmB,EAAE,CAAC;IAC1D,KAAAQ,uBAAuB,GAAG,IAAIR,eAAe,CAA0B,IAAIM,GAAG,EAAE,CAAC;IAEzF;IACQ,KAAAG,mBAAmB,GAA6B,IAAI;IACpD,KAAAC,mBAAmB,GAAG,IAAIV,eAAe,CAA2B,IAAI,CAAC;IACzE,KAAAW,eAAe,GAAqB,EAAE;IACtC,KAAAC,sBAAsB,GAAG,IAAIZ,eAAe,CAAmB,EAAE,CAAC;EAE7B;EAE7C;EACAa,UAAUA,CAAA;IACR,OAAO,IAAI,CAACN,cAAc,CAACO,YAAY,EAAE;EAC3C;EAEA;EACAC,mBAAmBA,CAAA;IACjB,OAAO,IAAI,CAACP,uBAAuB,CAACM,YAAY,EAAE;EACpD;EAEA;EACAE,eAAeA,CAAA;IACb,OAAO,IAAI,CAACN,mBAAmB,CAACI,YAAY,EAAE;EAChD;EAEA;EACAG,kBAAkBA,CAAA;IAChB,OAAO,IAAI,CAACL,sBAAsB,CAACE,YAAY,EAAE;EACnD;EAEA;EACAI,YAAYA,CAACC,KAAa,EAAEC,MAAc,EAAEC,MAAuB,EAAEC,SAAc,EAAEC,SAAc;IACjG,MAAMC,MAAM,GAAmB;MAC7BL,KAAK;MACLC,MAAM;MACNC,MAAM;MACNC,SAAS;MACTC,SAAS;MACTE,SAAS,EAAE,IAAIC,IAAI;KACpB;IAED,IAAI,CAACtB,OAAO,CAACuB,IAAI,CAACH,MAAM,CAAC;IACzB,IAAI,CAACjB,cAAc,CAACqB,IAAI,CAAC,CAAC,GAAG,IAAI,CAACxB,OAAO,CAAC,CAAC;IAE3C;IACA,MAAMyB,OAAO,GAAG,GAAGV,KAAK,IAAIC,MAAM,IAAIC,MAAM,EAAE;IAC9C,MAAMS,UAAU,GAAe;MAC7BX,KAAK;MACLC,MAAM;MACNC,MAAM;MACNU,WAAW,EAAE,IAAI;MACjBN,SAAS,EAAE,IAAIC,IAAI;KACpB;IAED,IAAI,CAACrB,gBAAgB,CAAC2B,GAAG,CAACH,OAAO,EAAEC,UAAU,CAAC;IAC9C,IAAI,CAACtB,uBAAuB,CAACoB,IAAI,CAAC,IAAItB,GAAG,CAAC,IAAI,CAACD,gBAAgB,CAAC,CAAC;IAEjE;IACA4B,UAAU,CAAC,MAAK;MACd,IAAI,CAACC,eAAe,CAACL,OAAO,CAAC;IAC/B,CAAC,EAAE,KAAK,CAAC;IAET;IACA,IAAI,CAACM,iBAAiB,CAAC,GAAGhB,KAAK,IAAIC,MAAM,EAAE,EAAEE,SAAS,EAAEC,SAAS,CAAC;EACpE;EAEA;EACAa,iBAAiBA,CAACjB,KAAa,EAAEC,MAAc,EAAEC,MAAuB;IACtE,MAAMQ,OAAO,GAAG,GAAGV,KAAK,IAAIC,MAAM,IAAIC,MAAM,EAAE;IAC9C,OAAO,IAAI,CAAChB,gBAAgB,CAACgC,GAAG,CAACR,OAAO,CAAC;EAC3C;EAEA;EACAS,aAAaA,CAACnB,KAAa,EAAEC,MAAc,EAAEC,MAAuB;IAClE,MAAMQ,OAAO,GAAG,GAAGV,KAAK,IAAIC,MAAM,IAAIC,MAAM,EAAE;IAC9C,OAAO,IAAI,CAAChB,gBAAgB,CAACkC,GAAG,CAACV,OAAO,CAAC,IAAI,IAAI;EACnD;EAEA;EACAK,eAAeA,CAACL,OAAe;IAC7B,IAAI,IAAI,CAACxB,gBAAgB,CAACgC,GAAG,CAACR,OAAO,CAAC,EAAE;MACtC,IAAI,CAACxB,gBAAgB,CAACmC,MAAM,CAACX,OAAO,CAAC;MACrC,IAAI,CAACrB,uBAAuB,CAACoB,IAAI,CAAC,IAAItB,GAAG,CAAC,IAAI,CAACD,gBAAgB,CAAC,CAAC;;EAErE;EAEA;EACAoC,kBAAkBA,CAAA;IAChB,IAAI,CAACpC,gBAAgB,CAACqC,KAAK,EAAE;IAC7B,IAAI,CAAClC,uBAAuB,CAACoB,IAAI,CAAC,IAAItB,GAAG,EAAE,CAAC;EAC9C;EAEA;EACAqC,eAAeA,CAACxB,KAAa;IAC3B,OAAO,IAAI,CAACf,OAAO,CAACwC,MAAM,CAACpB,MAAM,IAAIA,MAAM,CAACL,KAAK,KAAKA,KAAK,CAAC;EAC9D;EAEA;EACA0B,YAAYA,CAAA;IACV,IAAI,CAACzC,OAAO,GAAG,EAAE;IACjB,IAAI,CAACG,cAAc,CAACqB,IAAI,CAAC,EAAE,CAAC;IAC5B,IAAI,CAACa,kBAAkB,EAAE;EAC3B;EAEA;EACAK,yBAAyBA,CAACC,QAAgB;IACxC,IAAI;MACF;MACA,MAAMC,aAAa,GAAG,sDAAsD;MAC5E,MAAMC,YAAY,GAAG,4CAA4C;MAEjE,IAAIC,KAAK;MAET;MACA,OAAO,CAACA,KAAK,GAAGF,aAAa,CAACG,IAAI,CAACJ,QAAQ,CAAC,MAAM,IAAI,EAAE;QACtD,MAAM,GAAG5B,KAAK,EAAEC,MAAM,EAAEgC,QAAQ,EAAEC,QAAQ,CAAC,GAAGH,KAAK;QACnD;QACA,IAAI,CAAChC,YAAY,CAACC,KAAK,EAAEC,MAAM,EAAE,OAAO,EAAEgC,QAAQ,CAACE,IAAI,EAAE,EAAED,QAAQ,CAACC,IAAI,EAAE,CAAC;;MAG7E;MACA,OAAO,CAACJ,KAAK,GAAGD,YAAY,CAACE,IAAI,CAACJ,QAAQ,CAAC,MAAM,IAAI,EAAE;QACrD,MAAM,GAAGQ,SAAS,EAAEH,QAAQ,EAAEC,QAAQ,CAAC,GAAGH,KAAK;QAC/C;QACA,IAAI,CAAChC,YAAY,CAAC,YAAY,EAAEqC,SAAS,EAAE,OAAO,EAAEH,QAAQ,CAACE,IAAI,EAAE,EAAED,QAAQ,CAACC,IAAI,EAAE,CAAC;;KAExF,CAAC,OAAOE,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,sCAAsC,EAAEA,KAAK,CAAC;;EAEhE;EAEA;EACQrB,iBAAiBA,CAACuB,cAAsB,EAAEN,QAAa,EAAEC,QAAa;IAC5E;IACA,IAAI,IAAI,CAAC5C,mBAAmB,IAAI,IAAI,CAACA,mBAAmB,CAACkD,MAAM,KAAK,SAAS,EAAE;MAC7E;;IAGF,MAAMC,iBAAiB,GAAG,YAAYF,cAAc,KAAKN,QAAQ,MAAMC,QAAQ,EAAE;IAEjF;IACA,IAAI,CAACQ,uBAAuB,EAAE,CAACC,IAAI,CAACC,MAAM,IAAG;MAC3C,MAAMC,OAAO,GAAsB;QACjCC,EAAE,EAAEvC,IAAI,CAACwC,GAAG,EAAE,CAACC,QAAQ,EAAE;QACzBC,kBAAkB,EAAER,iBAAiB;QACrCS,gBAAgB,EAAEN,MAAM,CAACO,GAAG,CAACC,CAAC,IAAIA,CAAC,CAACC,QAAQ,CAAC;QAC7CC,iBAAiB,EAAEV,MAAM,CAACW,IAAI,CAACH,CAAC,IAAIA,CAAC,CAACI,IAAI,KAAK,QAAQ,CAAC,EAAEH,QAAQ;QAClE/C,SAAS,EAAE,IAAIC,IAAI,EAAE;QACrBiC,MAAM,EAAE;OACT;MAED,IAAI,CAAClD,mBAAmB,GAAGuD,OAAO;MAClC,IAAI,CAACtD,mBAAmB,CAACkB,IAAI,CAACoC,OAAO,CAAC;MACtC,IAAI,CAACpD,sBAAsB,CAACgB,IAAI,CAACmC,MAAM,CAAC;IAC1C,CAAC,CAAC;EACJ;EAEA;EACcF,uBAAuBA,CAAA;IAAA,IAAAe,KAAA;IAAA,OAAAC,iBAAA;MACnC,IAAI;QACF,MAAM9B,QAAQ,SAAS6B,KAAI,CAACzE,UAAU,CAAC2E,cAAc,EAAE,CAACC,SAAS,EAAE;QACnE,MAAMhB,MAAM,GAAqB,EAAE;QAEnC;QACA,MAAMiB,aAAa,GAAG,CACpB;UAAEC,OAAO,EAAE,SAAS;UAAEN,IAAI,EAAE,QAAiB;UAAEO,WAAW,EAAE;QAAgB,CAAE,EAC9E;UAAED,OAAO,EAAE,YAAY;UAAEN,IAAI,EAAE,MAAe;UAAEO,WAAW,EAAE;QAAuB,CAAE,EACtF;UAAED,OAAO,EAAE,eAAe;UAAEN,IAAI,EAAE,OAAgB;UAAEO,WAAW,EAAE;QAAc,CAAE,EACjF;UAAED,OAAO,EAAE,aAAa;UAAEN,IAAI,EAAE,OAAgB;UAAEO,WAAW,EAAE;QAAY,CAAE,EAC7E;UAAED,OAAO,EAAE,iBAAiB;UAAEN,IAAI,EAAE,OAAgB;UAAEO,WAAW,EAAE;QAAgB,CAAE,CACtF;QAED;QACA,MAAMC,eAAe,GAAGpC,QAAQ,CAACqC,KAAK,IAAI,EAAE;QAE5CD,eAAe,CAACE,OAAO,CAAEb,QAAgB,IAAI;UAC3C,KAAK,MAAMS,OAAO,IAAID,aAAa,EAAE;YACnC,IAAIC,OAAO,CAACA,OAAO,CAACK,IAAI,CAACd,QAAQ,CAAC,EAAE;cAClCT,MAAM,CAACpC,IAAI,CAAC;gBACV6C,QAAQ;gBACRG,IAAI,EAAEM,OAAO,CAACN,IAAI;gBAClBO,WAAW,EAAED,OAAO,CAACC,WAAW;gBAChCnD,WAAW,EAAEkD,OAAO,CAACN,IAAI,KAAK,QAAQ,CAAC;eACxC,CAAC;;cACF;;;QAGN,CAAC,CAAC;QAEF;QACA,IAAIZ,MAAM,CAACwB,MAAM,KAAK,CAAC,EAAE;UACvB,MAAMC,aAAa,GAAG,CACpB,WAAW,EACX,YAAY,EACZ,mBAAmB,EACnB,SAAS,EACT,iBAAiB,EACjB,kBAAkB,EAClB,iBAAiB,CAClB;UAEDA,aAAa,CAACH,OAAO,CAACb,QAAQ,IAAG;YAC/B,KAAK,MAAMS,OAAO,IAAID,aAAa,EAAE;cACnC,IAAIC,OAAO,CAACA,OAAO,CAACK,IAAI,CAACd,QAAQ,CAAC,EAAE;gBAClCT,MAAM,CAACpC,IAAI,CAAC;kBACV6C,QAAQ;kBACRG,IAAI,EAAEM,OAAO,CAACN,IAAI;kBAClBO,WAAW,EAAED,OAAO,CAACC,WAAW;kBAChCnD,WAAW,EAAEkD,OAAO,CAACN,IAAI,KAAK;iBAC/B,CAAC;gBACF;;;UAGN,CAAC,CAAC;;QAGJ,OAAOZ,MAAM;OACd,CAAC,OAAOP,KAAK,EAAE;QACdC,OAAO,CAACD,KAAK,CAAC,2BAA2B,EAAEA,KAAK,CAAC;QACjD,OAAO,EAAE;;IACV;EACH;EAEA;EACAiC,iBAAiBA,CAACC,aAAqB;IACrC,IAAI,IAAI,CAACjF,mBAAmB,EAAE;MAC5B,IAAI,CAACA,mBAAmB,CAACkD,MAAM,GAAG,UAAU;MAC5C,IAAI,CAAClD,mBAAmB,CAACkF,cAAc,GAAGD,aAAa;MACvD,IAAI,CAAChF,mBAAmB,CAACkB,IAAI,CAAC,IAAI,CAACnB,mBAAmB,CAAC;MAEvDgD,OAAO,CAACmC,GAAG,CAAC,kCAAkCF,aAAa,EAAE,CAAC;MAC9D;MACA,IAAI,CAACG,YAAY,CAACH,aAAa,CAAC;;EAEpC;EAEA;EACAI,gBAAgBA,CAAA;IACd,IAAI,IAAI,CAACrF,mBAAmB,EAAE;MAC5B,IAAI,CAACA,mBAAmB,CAACkD,MAAM,GAAG,UAAU;MAC5C,IAAI,CAACjD,mBAAmB,CAACkB,IAAI,CAAC,IAAI,CAACnB,mBAAmB,CAAC;MAEvDgD,OAAO,CAACmC,GAAG,CAAC,2BAA2B,CAAC;MACxC;MACA3D,UAAU,CAAC,MAAK;QACd,IAAI,CAAC8D,iBAAiB,EAAE;MAC1B,CAAC,EAAE,IAAI,CAAC;;EAEZ;EAEA;EACAA,iBAAiBA,CAAA;IACf,IAAI,CAACtF,mBAAmB,GAAG,IAAI;IAC/B,IAAI,CAACC,mBAAmB,CAACkB,IAAI,CAAC,IAAI,CAAC;IACnC,IAAI,CAAChB,sBAAsB,CAACgB,IAAI,CAAC,EAAE,CAAC;EACtC;EAEA;EACQiE,YAAYA,CAACG,aAAqB;IACxCvC,OAAO,CAACmC,GAAG,CAAC,oBAAoBI,aAAa,EAAE,CAAC;IAEhD,IAAI,CAAC7F,UAAU,CAAC0F,YAAY,CAACG,aAAa,CAAC,CAACC,SAAS,CAAC;MACpDrE,IAAI,EAAGmB,QAAQ,IAAI;QACjBU,OAAO,CAACmC,GAAG,CAAC,2BAA2B,EAAE7C,QAAQ,CAAC;QAClD;QACAd,UAAU,CAAC,MAAK;UACd,IAAI,CAAC8D,iBAAiB,EAAE;QAC1B,CAAC,EAAE,IAAI,CAAC;MACV,CAAC;MACDvC,KAAK,EAAGA,KAAK,IAAI;QACfC,OAAO,CAACD,KAAK,CAAC,wBAAwB,EAAEA,KAAK,CAAC;QAC9C;QACAvB,UAAU,CAAC,MAAK;UACd,IAAI,CAAC8D,iBAAiB,EAAE;QAC1B,CAAC,EAAE,IAAI,CAAC;MACV;KACD,CAAC;EACJ;;;uBAzRW9F,uBAAuB,EAAAiG,EAAA,CAAAC,QAAA,CAAAC,EAAA,CAAAC,UAAA;IAAA;EAAA;;;aAAvBpG,uBAAuB;MAAAqG,OAAA,EAAvBrG,uBAAuB,CAAAsG,IAAA;MAAAC,UAAA,EAFtB;IAAM;EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}